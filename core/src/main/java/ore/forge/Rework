Rework of the Map class and pretty much entire game.
    TheMap goes from a 2D array of Items to a 1D array of Tiles
    Each Tiles Has a vector2(its position) and can hold a Block.
    An Item is a collection of Blocks.
    Specific Blocks have certain functions and properties. (Conveyor Blocks, UpgradeBlocks, SourceBlocks(ore), etc)
        For example a conveyor block has a direction and can hold An Ore object, we can then use the vector2 of
        the tile that the ConveyorBlock is on & the direction to determine if the Ore can be moved forward to the next Block.

        An UpgradeBlock would extend ConveyorBlock, and would upgrade the ore its storing when it
        goes to move it to the next block.

        If A block Is a solid Block then it wont be able to store an ore Object.


How Do I ensure that blocks are fired in the desired order?
    Desired Order: Want to activate blocks in an order that prevents ore from jumping/moving/teleporting
     in a tick. Basically we can accomplish this goal by ensuring that an ore is only able to move once per tick.

    Solution 1: Ore has a boolean flag that determines whether or not the ore can be
     processed(upgraded & moved). An ore is flagged when moved, ensuring that it wont be able to move
     again during the same tick. At the end of each tick all ore have the flag removed.

    Solution 2: Instead of Iterating over all the Tiles in the map we iterate over the list of active ore.
     Each ore would have a reference/pointer to the object that is holding it and we would call on the
     blocks that way. This means we only get "hits"/ go over Blocks that actually need to be Activated.

            Expanding on the section where we iterate over a list of active ore. What if we used a queue
            each ore method would return a boolean indicating whether the ore had moved or not that tick.
            if false(which indicates that the ore wasnt able to move that tick) we take the ore and move it
            to the back of the queue to fire again in hopes that it will move?
                (Might not work due to intersections)

            The solution to this smells like a Stack

    Solution3: NA



How the new version of TycoonTick will function.
   1st: Iterate through all active ores in that are appart of ActiveOre.
        Ore will have a reference to where they are at on the map. They will call to the block located at that position on the map to process the ore, passing themself into the method...
                ore.process();

                process() { //implementation of the process method for the ore.
                   map.geBlock(vector).process(this);
                }

                block.process(Ore ore) { //implementation of the process method for the block.
                    //logic to upgrade or sell the ore depending on what type of block you are. If furnance teh rest of the steps bellow dont apply to you!
                    if(!map.getBlockInFront(Vector2 vector, Direction direction).isSolid || !block.isOpen) { //Check to see if the block in front is eligible (Might rework this so the map doesnt have to get the block each time.
                            return;
                    } else {
                        ore.setVector(map.getBlockInFront.getVector) {
                        blockInFront.isFull(); //set teh block in front to full because it now has an ore.
                        this.isOpen(); //Set this block to empty because it has now moved the ore.
                        }
                    }


                }



   2nd: Iterate over all Droppers to produce ore.


   public <TYPE> gameTick() {
        for (Ore ore : activeOre) {
            ore.activateBlock();
        }

        for (DropperBlock dropper : Droppers) {
            dropper.produceOre();
        }

        return <TYPE>
   }

  <TYPE> in this scenario TYPE would be an object that contains a list of all active ore objects and all Items on the map. Would then be able to iterate through and draw them all.


Types of blocks:
   1. defaultBlock - Block has no behaviors/functions like a wall, cant move ore

   2. conveyorBlock - This block moves ore to the block infront of it.

   3. UpgradeBlock - in addition to functioning like a conveyorBlock upgradeBlock will also upgrade ore before moving it.

   4. furnaceBlock - upgrades ore on top of it then sells it.

   5. dropperBlock - produces/spawns ore ontop of this block the pushes it to the block in-front of it.

for(Item item : placedItems) {
   batch.draw(item.getTexture, item.vector.x, item.vector.y)
}



